using Spectre.Console;
using Aspire_Full.Pipeline.Utils;
using Aspire_Full.Pipeline.Constants;

namespace Aspire_Full.Pipeline.Services;

public class CiService
{
    public async Task SetupRunnerAsync(string token, string repo)
    {
        if (string.IsNullOrEmpty(token))
        {
            AnsiConsole.MarkupLine("[red]GitHub Token is required. Use --token <token>[/]");
            return;
        }

        AnsiConsole.MarkupLine("[cyan]=== Setting up GitHub Actions Runner ===[/]");

        // Ensure Infra (Network and Volumes)
        await DockerUtils.CreateNetworkAsync(DockerConstants.NetworkName);
        await DockerUtils.CreateVolumeAsync("github-runner-data"); // This one wasn't in DockerConstants, maybe I should add it or just leave it here if it's specific.
        // Actually "aspire-runner-data" is in DockerConstants. "github-runner-data" seems to be a mistake in CiModule or a different one.
        // Looking at InfraModule, it had "aspire-runner-data".
        // Looking at CiModule, it had "github-runner-data".
        // I should probably standardize. Let's use "aspire-runner-data" if possible, or stick to what was there if it matters.
        // The docker-compose.yml likely uses "github-runner-data" or similar.
        // I'll stick to what was in CiModule for now to avoid breaking changes, but I should probably check docker-compose.yml.
        // For now, I'll just use the string literal or add it to constants if I want to be strict.
        // I'll add it to DockerConstants as a separate one if needed, or just use "github-runner-data".

        // Create .env file
        var root = GitUtils.GetRepositoryRoot();
        var envFile = Path.Combine(root, PathConstants.DevContainerEnv);
        var content = $@"# GitHub Actions Runner Configuration
# Generated by Aspire-Full.Pipeline on {DateTime.Now:yyyy-MM-dd HH:mm:ss}

GITHUB_TOKEN={token}
GITHUB_REPOSITORY={repo}
RUNNER_NAME=aspire-runner
RUNNER_LABELS=self-hosted,Linux,X64,docker,dotnet,aspire
RUNNER_GROUP=Default
";
        await File.WriteAllTextAsync(envFile, content);
        AnsiConsole.MarkupLine($"[green]Created environment file: {envFile}[/]");

        await StartRunnerAsync();
    }

    public async Task StartRunnerAsync()
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, PathConstants.DevContainerCompose);
        var workDir = Path.GetDirectoryName(composeFile)!;

        AnsiConsole.MarkupLine("[green]Starting runner service...[/]");
        await ProcessUtils.RunAsync("docker", ["compose", "up", "-d", DockerConstants.RunnerContainerName], workDir, silent: false);
    }

    public async Task StopRunnerAsync()
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, PathConstants.DevContainerCompose);
        var workDir = Path.GetDirectoryName(composeFile)!;

        AnsiConsole.MarkupLine("[yellow]Stopping runner service...[/]");
        await ProcessUtils.RunAsync("docker", ["compose", "stop", DockerConstants.RunnerContainerName], workDir, silent: false);
    }

    public async Task StatusRunnerAsync()
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, PathConstants.DevContainerCompose);
        var workDir = Path.GetDirectoryName(composeFile)!;

        await ProcessUtils.RunAsync("docker", ["compose", "ps", DockerConstants.RunnerContainerName], workDir, silent: false);
    }

    public async Task LogsRunnerAsync(bool follow)
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, PathConstants.DevContainerCompose);
        var workDir = Path.GetDirectoryName(composeFile)!;

        var args = new List<string> { "compose", "logs" };
        if (follow) args.Add("-f");
        else args.AddRange(["--tail", "100"]);
        args.Add(DockerConstants.RunnerContainerName);

        await ProcessUtils.RunAsync("docker", args.ToArray(), workDir, silent: false);
    }

    public async Task CacheListAsync()
    {
        await GhUtils.EnsureExtensionAsync("actions/gh-actions-cache");
        var repo = await GhUtils.GetRepoAsync();
        AnsiConsole.MarkupLine($"[yellow]Listing caches for {repo}...[/]");
        await ProcessUtils.RunAsync("gh", ["actions-cache", "list", "-R", repo], silent: false);
    }

    public async Task CacheDeleteAsync(string key)
    {
        if (string.IsNullOrEmpty(key))
        {
            AnsiConsole.MarkupLine("[red]Cache key is required. Use --key <key>[/]");
            return;
        }

        await GhUtils.EnsureExtensionAsync("actions/gh-actions-cache");
        var repo = await GhUtils.GetRepoAsync();
        AnsiConsole.MarkupLine($"[yellow]Deleting cache {key} from {repo}...[/]");
        await ProcessUtils.RunAsync("gh", ["actions-cache", "delete", key, "-R", repo, "--confirm"], silent: false);
    }

    public async Task CacheClearAsync()
    {
        await GhUtils.EnsureExtensionAsync("actions/gh-actions-cache");
        var repo = await GhUtils.GetRepoAsync();

        if (!AnsiConsole.Confirm($"Are you sure you want to clear ALL caches for {repo}?")) return;

        AnsiConsole.MarkupLine($"[red]Clearing all caches for {repo}...[/]");

        // List keys first
        var (code, output) = await ProcessUtils.RunAsync("gh", ["actions-cache", "list", "-R", repo, "--json", "key", "-q", ".[].key"], silent: true);
        var keys = output.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries);

        foreach (var key in keys)
        {
            AnsiConsole.MarkupLine($"Deleting {key}...");
            await ProcessUtils.RunAsync("gh", ["actions-cache", "delete", key, "-R", repo, "--confirm"], silent: false);
        }
        AnsiConsole.MarkupLine("[green]All caches cleared.[/]");
    }

    public async Task GenerateSbomAsync(string output)
    {
        await GhUtils.EnsureExtensionAsync("advanced-security/gh-sbom");
        var repo = await GhUtils.GetRepoAsync();
        AnsiConsole.MarkupLine($"[cyan]Generating SBOM for {repo}...[/]");

        // gh sbom outputs to stdout, we need to capture it
        var (code, sbomContent) = await ProcessUtils.RunAsync("gh", ["sbom", "-r", repo], silent: true);

        if (code != 0)
        {
            AnsiConsole.MarkupLine("[red]Failed to generate SBOM.[/]");
            return;
        }

        await File.WriteAllTextAsync(output, sbomContent);
        AnsiConsole.MarkupLine($"[green]SBOM generated: {output}[/]");
    }

    public async Task RunLocalAsync(string workflow, string job, string triggerEvent, bool list, bool dryRun, string pat, bool verbose)
    {
        await GhUtils.EnsureExtensionAsync("nektos/gh-act");

        // Check Docker
        var (code, _) = await ProcessUtils.RunAsync("docker", ["info"], silent: true);
        if (code != 0)
        {
            AnsiConsole.MarkupLine("[red]Docker is not running. Please start Docker Desktop.[/]");
            return;
        }

        var root = GitUtils.GetRepositoryRoot();

        if (list)
        {
            AnsiConsole.MarkupLine("[yellow]Available workflows:[/]");
            await ProcessUtils.RunAsync("gh", ["act", "-l"], root, silent: false);
            return;
        }

        var args = new List<string> { "act" };

        if (!string.IsNullOrEmpty(triggerEvent)) args.Add(triggerEvent);

        if (!string.IsNullOrEmpty(workflow))
        {
            args.Add("-W");
            args.Add($".github/workflows/{workflow}");
        }

        if (!string.IsNullOrEmpty(job))
        {
            args.Add("-j");
            args.Add(job);
        }

        if (dryRun)
        {
            args.Add("-n");
            AnsiConsole.MarkupLine("[yellow]Dry run mode enabled[/]");
        }

        if (verbose) args.Add("-v");

        if (!string.IsNullOrEmpty(pat))
        {
            args.Add("-s");
            args.Add($"GITHUB_TOKEN={pat}");
            AnsiConsole.MarkupLine("[green]Using provided PAT for authentication[/]");
        }

        AnsiConsole.MarkupLine($"[cyan]Running: gh {string.Join(" ", args)}[/]");
        await ProcessUtils.RunAsync("gh", args.ToArray(), root, silent: false);
    }
}
