using System.CommandLine;
using Spectre.Console;
using Aspire_Full.Pipeline.Utils;

namespace Aspire_Full.Pipeline.Modules.Ci;

public class CiModule
{
    public Command GetCommand()
    {
        var command = new Command("ci", "Manage CI/CD workflows");

        var runnerCommand = new Command("runner", "Manage GitHub Actions runner");

        // Setup
        var setupCommand = new Command("setup", "Setup and start the runner");
        var tokenOption = new Option<string>(["--token", "-t"], "GitHub Personal Access Token");
        var repoOption = new Option<string>(["--repo", "-r"], () => "DeanLuus22021994/Aspire-Full", "GitHub Repository");
        setupCommand.AddOption(tokenOption);
        setupCommand.AddOption(repoOption);
        setupCommand.SetHandler(SetupRunnerAsync, tokenOption, repoOption);
        runnerCommand.AddCommand(setupCommand);

        // Start
        var startCommand = new Command("start", "Start the runner service");
        startCommand.SetHandler(StartRunnerAsync);
        runnerCommand.AddCommand(startCommand);

        // Stop
        var stopCommand = new Command("stop", "Stop the runner service");
        stopCommand.SetHandler(StopRunnerAsync);
        runnerCommand.AddCommand(stopCommand);

        // Status
        var statusCommand = new Command("status", "Check runner status");
        statusCommand.SetHandler(StatusRunnerAsync);
        runnerCommand.AddCommand(statusCommand);

        // Logs
        var logsCommand = new Command("logs", "View runner logs");
        var followOption = new Option<bool>(["--follow", "-f"], "Follow logs");
        logsCommand.AddOption(followOption);
        logsCommand.SetHandler(LogsRunnerAsync, followOption);
        runnerCommand.AddCommand(logsCommand);

        command.AddCommand(runnerCommand);
        return command;
    }

    private async Task SetupRunnerAsync(string token, string repo)
    {
        if (string.IsNullOrEmpty(token))
        {
            AnsiConsole.MarkupLine("[red]GitHub Token is required. Use --token <token>[/]");
            return;
        }

        AnsiConsole.MarkupLine("[cyan]=== Setting up GitHub Actions Runner ===[/]");

        // Ensure Infra
        await new Infra.InfraModule().GetCommand().Parse("init").InvokeAsync("");

        // Create .env file
        var root = GitUtils.GetRepositoryRoot();
        var envFile = Path.Combine(root, ".devcontainer", ".env");
        var content = $@"# GitHub Actions Runner Configuration
# Generated by Aspire-Full.Pipeline on {DateTime.Now:yyyy-MM-dd HH:mm:ss}

GITHUB_TOKEN={token}
GITHUB_REPOSITORY={repo}
RUNNER_NAME=aspire-runner
RUNNER_LABELS=self-hosted,Linux,X64,docker,dotnet,aspire
RUNNER_GROUP=Default
";
        await File.WriteAllTextAsync(envFile, content);
        AnsiConsole.MarkupLine($"[green]Created environment file: {envFile}[/]");

        await StartRunnerAsync();
    }

    private async Task StartRunnerAsync()
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, ".devcontainer", "docker-compose.yml");
        var workDir = Path.GetDirectoryName(composeFile)!;

        AnsiConsole.MarkupLine("[green]Starting runner service...[/]");
        await ProcessUtils.RunAsync("docker", ["compose", "up", "-d", "github-runner"], workDir, silent: false);
    }

    private async Task StopRunnerAsync()
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, ".devcontainer", "docker-compose.yml");
        var workDir = Path.GetDirectoryName(composeFile)!;

        AnsiConsole.MarkupLine("[yellow]Stopping runner service...[/]");
        await ProcessUtils.RunAsync("docker", ["compose", "stop", "github-runner"], workDir, silent: false);
    }

    private async Task StatusRunnerAsync()
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, ".devcontainer", "docker-compose.yml");
        var workDir = Path.GetDirectoryName(composeFile)!;

        await ProcessUtils.RunAsync("docker", ["compose", "ps", "github-runner"], workDir, silent: false);
    }

    private async Task LogsRunnerAsync(bool follow)
    {
        var root = GitUtils.GetRepositoryRoot();
        var composeFile = Path.Combine(root, ".devcontainer", "docker-compose.yml");
        var workDir = Path.GetDirectoryName(composeFile)!;

        var args = new List<string> { "compose", "logs" };
        if (follow) args.Add("-f");
        else args.AddRange(["--tail", "100"]);
        args.Add("github-runner");

        // For logs -f we need to stream output, ProcessUtils might need adjustment or use RunProcessWithOutputAsync from Program.cs logic
        // But ProcessUtils.RunAsync captures output at end. For -f we need real-time.
        // I'll use a custom process call here or enhance ProcessUtils.

        var startInfo = new System.Diagnostics.ProcessStartInfo("docker")
        {
            WorkingDirectory = workDir,
            UseShellExecute = false,
            RedirectStandardOutput = true,
            RedirectStandardError = true
        };
        foreach (var arg in args) startInfo.ArgumentList.Add(arg);

        using var process = new System.Diagnostics.Process { StartInfo = startInfo };
        process.OutputDataReceived += (s, e) => { if (e.Data != null) Console.WriteLine(e.Data); };
        process.ErrorDataReceived += (s, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };

        process.Start();
        process.BeginOutputReadLine();
        process.BeginErrorReadLine();
        await process.WaitForExitAsync();
    }
}
