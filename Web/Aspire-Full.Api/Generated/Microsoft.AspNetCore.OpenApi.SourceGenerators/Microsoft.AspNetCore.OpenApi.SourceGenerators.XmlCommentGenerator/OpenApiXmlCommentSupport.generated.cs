//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
// Suppress warnings about obsolete types and members
// in generated code
#pragma warning disable CS0612, CS0618

namespace System.Runtime.CompilerServices
{
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.OpenApi.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.OpenApi;
    using Microsoft.AspNetCore.Mvc.Controllers;
    using Microsoft.AspNetCore.Mvc.ModelBinding.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.OpenApi;

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file record XmlComment(
        string? Summary,
        string? Description,
        string? Remarks,
        string? Returns,
        string? Value,
        bool Deprecated,
        List<string>? Examples,
        List<XmlParameterComment>? Parameters,
        List<XmlResponseComment>? Responses);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file record XmlParameterComment(string? Name, string? Description, string? Example, bool Deprecated);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file record XmlResponseComment(string Code, string? Description, string? Example);

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class XmlCommentCache
    {
        private static Dictionary<string, XmlComment>? _cache;
        public static Dictionary<string, XmlComment> Cache => _cache ??= GenerateCacheEntries();

        private static Dictionary<string, XmlComment> GenerateCacheEntries()
        {
            var cache = new Dictionary<string, XmlComment>();

            cache.Add(@"T:Aspire_Full.DockerRegistry.Abstractions.IDockerRegistryGpuMonitor", new XmlComment(@"DockerRegistry-specific interface for GPU resource monitoring.
Currently equivalent to IGpuResourceMonitor, but allows for future
DockerRegistry-specific extensions without breaking other consumers.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions", new XmlComment(@"Configuration options for interacting with a Docker registry using pattern-based repositories and tags.
Uses C# 14 field keyword for property validation.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.BaseAddress", new XmlComment(@"Registry base address. Supports HTTP or HTTPS. Defaults to a local development registry.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.CatalogPageSize", new XmlComment(@"Maximum number of repositories to request per catalog page.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.HttpTimeout", new XmlComment(@"Timeout for outgoing HTTP requests.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.AllowInsecureTls", new XmlComment(@"Whether to allow untrusted SSL certificates (development only).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.EnableOfflineFallback", new XmlComment(@"Whether to fall back to pattern-derived sample data when the registry cannot be reached.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.Credentials", new XmlComment(@"Credential configuration for the registry.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.Patterns", new XmlComment(@"Pattern configuration for repositories and tags.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.MaxWorkerPoolSize", new XmlComment(@"Maximum number of concurrent buildx workers.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.GarbageCollectionInterval", new XmlComment(@"Interval for garbage collection.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryOptions.GpuAcceleration", new XmlComment(@"GPU acceleration configuration for TensorCore builds.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions", new XmlComment(@"GPU acceleration configuration for NVIDIA CUDA builds.
Uses C# 14 field keyword for computed properties and validation.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.Enabled", new XmlComment(@"Whether GPU acceleration is enabled for BuildKit workers.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.CudaBootstrapDevelImage", new XmlComment(@"The CUDA bootstrap image for devel builds (compilation).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.CudaBootstrapRuntimeImage", new XmlComment(@"The CUDA bootstrap image for runtime builds (production).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.CudaCacheVolume", new XmlComment(@"Named volume for CUDA compilation cache.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.CcacheVolume", new XmlComment(@"Named volume for ccache (C/C++ compilation cache).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.BuildkitCacheVolume", new XmlComment(@"Named volume for BuildKit cache.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.TorchCudaArchList", new XmlComment(@"CUDA architectures to target for TensorCore builds.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.MinimumCudaVersion", new XmlComment(@"Minimum required CUDA version on the host.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.MinimumDriverVersion", new XmlComment(@"Minimum required NVIDIA driver version on the host.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.MaxGpuMemoryPoolBuffers", new XmlComment(@"Maximum number of GPU memory pool buffers.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.DefaultBufferSize", new XmlComment(@"Default buffer size for GPU memory pool allocations.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.IsHighPerformanceMode", new XmlComment(@"Returns true if high-performance mode is configured (Ampere+ architecture).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.RequiresCudaToolkit", new XmlComment(@"Returns true if the CUDA toolkit is required (devel image targets).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.NvidiaRequirement", new XmlComment(@"Gets the NVIDIA runtime requirement string.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.GpuAccelerationOptions.EstimatedGpuMemoryBytes", new XmlComment(@"Gets the total estimated GPU memory requirement in bytes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryPatternOptions.RepositoryTemplate", new XmlComment(@"Template for repository names. Supported tokens: namespace, service, environment, architecture, variant.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryPatternOptions.TagTemplate", new XmlComment(@"Template for tags. Supported tokens: version, environment, architecture, variant.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryPatternOptions.Namespace", new XmlComment(@"Default namespace used when formatting repositories.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Configuration.DockerRegistryPatternOptions.SampleServices", new XmlComment(@"A list of services used when sample repositories need to be generated offline.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Models.DockerImageDescriptor", new XmlComment(@"Represents the logical parts of a container image used for template formatting.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Models.DockerImageDescriptor.Metadata", new XmlComment(@"Additional metadata for traceability and rotation (e.g., build ID, timestamp, git commit).", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Native.GpuProcessExecutor", new XmlComment(@"GPU-accelerated process executor with real-time streaming and memory-mapped I/O.
Provides IAsyncEnumerable for streaming build output with GPU telemetry.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Native.GpuProcessExecutor.TelemetryEvents", new XmlComment(@"Channel reader for GPU telemetry events.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Native.GpuProcessExecutor.ExecuteStreamingAsync(System.String,System.String,System.Threading.CancellationToken)", new XmlComment(@"Executes a command with real-time output streaming.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Native.GpuProcessExecutor.ExecuteBuildxAsync(System.String,System.String,System.String,System.String,System.Threading.CancellationToken)", new XmlComment(@"Executes a buildx command with GPU passthrough and memory-mapped artifact handling.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Native.GpuProcessExecutor.ProcessArtifactWithGpuAsync(System.String,System.Threading.CancellationToken)", new XmlComment(@"Processes a large artifact file using memory-mapped I/O for zero-copy GPU access.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Services.ImageValidationPipeline", new XmlComment(@"GPU-accelerated image validation pipeline with TensorPrimitives fallback.
Uses portable SIMD operations when GPU is unavailable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Services.ImageValidationPipeline.ValidateManifestAsync(Aspire_Full.DockerRegistry.Models.DockerManifest,System.Threading.CancellationToken)", new XmlComment(@"Validates a manifest using GPU-accelerated tensor operations when available.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Services.SafetensorsArtifactHandler", new XmlComment(@"High-performance safetensors artifact handler with zero-copy GPU processing.
Uses memory-mapped files and IAsyncEnumerable for streaming large model files.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Services.SafetensorsArtifactHandler.ChunkReader", new XmlComment(@"Channel reader for streaming tensor chunks during processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Services.SafetensorsArtifactHandler.ProcessFileAsync(System.String,System.Threading.CancellationToken)", new XmlComment(@"Processes a safetensors file using memory-mapped I/O for zero-copy GPU access.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Services.SafetensorsArtifactHandler.StreamChunksAsync(System.String,System.UIntPtr,System.Threading.CancellationToken)", new XmlComment(@"Streams a safetensors file as tensor chunks for incremental processing.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Services.SafetensorsArtifactHandler.ProcessStreamAsync(System.IO.Stream,System.Threading.CancellationToken)", new XmlComment(@"Processes a stream using zero-copy pipeline for GPU offload.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Services.SafetensorsArtifactHandler.ValidateTensorDataAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)", new XmlComment(@"Validates tensor data integrity using GPU-accelerated hashing.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Workers.ExportResult", new XmlComment(@"Result of an export operation.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory", new XmlComment(@"Factory for GPU-accelerated BuildKit workers with integrated resource monitoring.
Implements IDockerRegistryGpuMonitor for telemetry and memory pool management.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.IsGpuAvailable", new XmlComment(@"Returns true if GPU compute is available.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.DeviceCount", new XmlComment(@"Gets the number of GPU devices.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.CurrentUtilization", new XmlComment(@"Gets current GPU utilization percentage.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.TotalMemory", new XmlComment(@"Gets estimated total GPU memory based on configuration.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.AllocatedMemory", new XmlComment(@"Gets currently allocated GPU memory from the pool.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.AvailableMemory", new XmlComment(@"Gets available GPU memory.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.MemoryPool", new XmlComment(@"Gets the GPU memory pool.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.GpuAccelerationOptions", new XmlComment(@"Gets the GPU acceleration options.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.ProcessExecutor", new XmlComment(@"Gets the GPU process executor for streaming operations.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.RecordOperation(Aspire_Full.Tensor.Core.Abstractions.GpuOperationType,System.Double,System.Int64)", new XmlComment(@"Records a GPU compute operation for metrics.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.RefreshAsync(System.Threading.CancellationToken)", new XmlComment(@"Refreshes GPU statistics from the device.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.DockerRegistry.Workers.BuildxWorkerFactory.GetDeviceSnapshotAsync(System.Int32,System.Threading.CancellationToken)", new XmlComment(@"Gets a snapshot of GPU device state.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Program", new XmlComment(@"Auto-generated public partial Program class for top-level statement apps.", null, null, null, null, false, null, null, null));


            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Boolean", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.NullableBoolean", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Double", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.NullableDouble", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.AgentInput", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.AgentOutput", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.AgentSettings", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.CreateUser", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DelegatedWorkItem", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DelegationPriority", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DockerManifest", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DockerManifestLayer", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DockerRegistryRepository", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.RegistrySettings", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Settings", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.SubagentDefinition", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.SubagentDelegationPlan", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.SubagentRetrospective", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.SubagentRole", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.TensorInferenceChunk", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.TensorJobStatus", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.TensorJobSubmission", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.TensorJobSummary", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.TensorModelSummary", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.UpdateUser", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.User", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.UserRole", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DictionaryStringObject", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.IDictionaryStringString", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.IListDockerManifestLayer", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.IListTensorInferenceChunk", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.IReadOnlyListDelegatedWorkItem", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.IReadOnlyListString", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.ListDockerRegistryRepository", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.ListTensorJobSummary", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.ListTensorModelSummary", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.ListUser", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DateTime", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.NullableDateTime", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.DateTimeOffset", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.NullableDateTimeOffset", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Guid", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Int32", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Int64", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Object", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.String", new XmlComment(@"Defines the source generated JSON serialization contract metadata for a given type.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Shared.AppJsonContext.Default", new XmlComment(@"The default JsonSerializerContext associated with a default JsonSerializerOptions instance.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Shared.AppJsonContext.#ctor", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Shared.AppJsonContext.#ctor(System.Text.Json.JsonSerializerOptions)", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Shared.AppJsonContext.GetTypeInfo(System.Type)", new XmlComment(null, null, null, null, null, false, null, null, null));

            cache.Add(@"T:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime", new XmlComment(@"Interface for tensor compute runtime providing GPU/CPU abstraction.
Implementations can optimize for specific hardware capabilities.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.IsGpuAvailable", new XmlComment(@"Gets whether GPU compute is available.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.DeviceCount", new XmlComment(@"Gets the number of GPU devices.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.MemoryPool", new XmlComment(@"Gets the GPU memory pool for buffer management.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.CosineSimilarity(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})", new XmlComment(@"Computes cosine similarity between two vectors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.Norm(System.ReadOnlySpan{System.Single})", new XmlComment(@"Computes L2 norm of a vector.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.Dot(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})", new XmlComment(@"Computes dot product of two vectors.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.SoftMax(System.ReadOnlySpan{System.Single},System.Span{System.Single})", new XmlComment(@"Applies softmax activation.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.ReLU(System.ReadOnlySpan{System.Single},System.Span{System.Single})", new XmlComment(@"Applies ReLU activation.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.MatrixMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single},System.Int32,System.Int32,System.Int32)", new XmlComment(@"Performs matrix multiplication: C = A * B.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.MeanPooling(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Int64},System.Span{System.Single},System.Int32,System.Int32,System.Int32)", new XmlComment(@"Performs mean pooling for transformer embeddings.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.ValidateContent(System.ReadOnlySpan{System.Single},System.Single,Aspire_Full.Tensor.Core.Native.NativeTensorContext.TensorMetrics@)", new XmlComment(@"Validates tensor data against a threshold.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.ITensorRuntime.GetDeviceInfo(System.Int32)", new XmlComment(@"Gets device information for a specific GPU.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor", new XmlComment(@"Interface for monitoring GPU resources with telemetry integration.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.IsGpuAvailable", new XmlComment(@"Gets whether GPU acceleration is available.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.DeviceCount", new XmlComment(@"Gets the number of available GPU devices.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.CurrentUtilization", new XmlComment(@"Gets current GPU utilization as a percentage (0-100).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.TotalMemory", new XmlComment(@"Gets the total GPU memory in bytes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.AllocatedMemory", new XmlComment(@"Gets the currently allocated GPU memory in bytes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.AvailableMemory", new XmlComment(@"Gets the available GPU memory in bytes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.MemoryPool", new XmlComment(@"Gets the GPU memory pool for buffer management.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.RecordOperation(Aspire_Full.Tensor.Core.Abstractions.GpuOperationType,System.Double,System.Int64)", new XmlComment(@"Records a GPU compute operation for metrics.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.RefreshAsync(System.Threading.CancellationToken)", new XmlComment(@"Refreshes GPU statistics from the device.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Abstractions.IGpuResourceMonitor.GetDeviceSnapshotAsync(System.Int32,System.Threading.CancellationToken)", new XmlComment(@"Gets detailed device information for a specific GPU.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Abstractions.GpuOperationType", new XmlComment(@"Types of GPU compute operations for metrics tracking.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Abstractions.GpuDeviceSnapshot", new XmlComment(@"Snapshot of GPU device state at a point in time.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.GpuDeviceSnapshot.ComputeCapability", new XmlComment(@"Gets the compute capability as a version string (e.g., ""8.6"").", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Abstractions.GpuDeviceSnapshot.MemoryUtilization", new XmlComment(@"Gets the memory utilization as a percentage.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool", new XmlComment(@"High-performance GPU memory pool with pre-allocated device buffers.
Uses C# 14 features and .NET 10 TensorPrimitives for portable compute.
Thread-safe buffer management with automatic CPU fallback.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.TotalAllocated", new XmlComment(@"Total number of allocated GPU buffers.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.TotalBytesAllocated", new XmlComment(@"Total bytes allocated across all GPU buffers.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.AvailableCount", new XmlComment(@"Number of available buffers in the pool.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.MaxBufferCount", new XmlComment(@"Maximum buffer count for this pool.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.DefaultBufferSize", new XmlComment(@"Default buffer size in bytes.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.IsUsingGpu", new XmlComment(@"Whether GPU acceleration is being used for buffers.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.Rent(System.UIntPtr)", new XmlComment(@"Rents a GPU buffer from the pool, allocating if necessary.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.Return(Aspire_Full.Tensor.Core.Memory.GpuBuffer)", new XmlComment(@"Returns a GPU buffer to the pool for reuse.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.ExecuteBatch(System.ReadOnlySpan{Aspire_Full.Tensor.Core.Memory.GpuOperation})", new XmlComment(@"Executes a batch of GPU operations using pooled memory.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuMemoryPool.RentAsync(System.UIntPtr,System.Threading.CancellationToken)", new XmlComment(@"Asynchronously rents a buffer, waiting if pool is exhausted.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Memory.GpuBuffer", new XmlComment(@"Represents a GPU device buffer with zero-copy host access.
Automatically falls back to pinned managed memory when GPU unavailable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.AsSpan", new XmlComment(@"Gets a span over the host-mapped memory for zero-copy access.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.AsMemory", new XmlComment(@"Gets a memory over the host-mapped memory for async operations.
For GPU buffers, creates a managed copy; for CPU buffers, wraps the pinned array.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.AsSpan``1", new XmlComment(@"Gets a span of the specified type over host-mapped memory.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.Allocate(System.UIntPtr)", new XmlComment(@"Allocates a new GPU buffer with host-mapped memory.
Automatically falls back to pinned managed memory when GPU unavailable.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.Reset", new XmlComment(@"Resets the buffer for reuse without deallocation.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.CopyToDevice", new XmlComment(@"Copies data from host to device (GPU only).", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuBuffer.CopyToHost", new XmlComment(@"Copies data from device to host (GPU only).", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Memory.GpuBufferScope", new XmlComment(@"RAII scope for GPU buffer usage with automatic return.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Memory.GpuOperation", new XmlComment(@"Represents a GPU compute operation for batched execution.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Memory.GpuOperation.#ctor(System.UIntPtr,System.Action{Aspire_Full.Tensor.Core.Memory.GpuBuffer})", new XmlComment(@"Represents a GPU compute operation for batched execution.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Native.NativeLibraryResolver.IsNativeLoaded", new XmlComment(@"Gets whether the native library is loaded successfully.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Native.NativeLibraryResolver.LoadedLibraryPath", new XmlComment(@"Gets the path of the loaded native library, if available.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Native.NativeLibraryResolver.LoadError", new XmlComment(@"Gets any error message from library loading.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeLibraryResolver.Initialize", new XmlComment(@"Initializes the native library resolver.
Call this early in application startup to ensure proper library discovery.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeLibraryResolver.GetDiagnostics", new XmlComment(@"Gets diagnostic information about the native library loading state.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Native.NativeLibraryDiagnostics", new XmlComment(@"Diagnostic information for native library loading.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Native.NativeTensorContext.TensorMetrics", new XmlComment(@"Unified tensor metrics struct matching native layout.
Contains all fields from both DockerRegistry and ML compute contexts.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.Native.NativeTensorContext.GpuDeviceInfo", new XmlComment(@"GPU device information for capability detection.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Native.NativeTensorContext.GpuDeviceCount", new XmlComment(@"Thread-safe GPU device count with lazy initialization.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Tensor.Core.Native.NativeTensorContext.IsGpuAvailable", new XmlComment(@"Returns true if GPU compute is available.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.ResetDeviceCache", new XmlComment(@"Resets the cached GPU device count to force re-detection.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.CosineSimilarity(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})", new XmlComment(@"Computes cosine similarity between two vectors.
Uses GPU when available, falls back to TensorPrimitives SIMD.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.Norm(System.ReadOnlySpan{System.Single})", new XmlComment(@"Computes the L2 norm of a vector.
Uses GPU when available, falls back to TensorPrimitives SIMD.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.Dot(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})", new XmlComment(@"Computes dot product of two vectors.
Uses GPU when available, falls back to TensorPrimitives SIMD.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.SoftMax(System.ReadOnlySpan{System.Single},System.Span{System.Single})", new XmlComment(@"Applies softmax activation.
Uses GPU when available, falls back to TensorPrimitives SIMD.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.ReLU(System.ReadOnlySpan{System.Single},System.Span{System.Single})", new XmlComment(@"Applies ReLU activation.
Uses GPU when available, falls back to element-wise max.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.ValidateContent(System.ReadOnlySpan{System.Single},System.Single,Aspire_Full.Tensor.Core.Native.NativeTensorContext.TensorMetrics@)", new XmlComment(@"Validates tensor content with threshold check.
Uses GPU when available, falls back to TensorPrimitives.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.Add(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})", new XmlComment(@"Performs element-wise addition: destination = x + y.
Uses GPU when available, falls back to TensorPrimitives SIMD.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Tensor.Core.Native.NativeTensorContext.Multiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})", new XmlComment(@"Performs element-wise multiplication: destination = x * y.
Uses GPU when available, falls back to TensorPrimitives SIMD.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Tensor.Core.TensorRuntime", new XmlComment(@"Default tensor runtime implementation with GPU/CPU fallback.
Provides unified access to GPU compute operations via NativeTensorContext.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Microsoft.Extensions.DependencyInjection.TensorCoreServiceCollectionExtensions.AddTensorCore(Microsoft.Extensions.DependencyInjection.IServiceCollection)", new XmlComment(@"Adds Tensor.Core services to the service collection.
Registers ITensorRuntime and IGpuResourceMonitor as singletons.", null, null, @"The service collection for chaining.", null, false, null, [new XmlParameterComment(@"services", @"The service collection.", null, false)], null));
            cache.Add(@"M:Microsoft.Extensions.DependencyInjection.TensorCoreServiceCollectionExtensions.AddTensorCore(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.Extensions.DependencyInjection.TensorCoreOptions})", new XmlComment(@"Adds Tensor.Core services with custom configuration.", null, null, @"The service collection for chaining.", null, false, null, [new XmlParameterComment(@"services", @"The service collection.", null, false), new XmlParameterComment(@"configure", @"Optional configuration action.", null, false)], null));
            cache.Add(@"M:Microsoft.Extensions.DependencyInjection.TensorCoreServiceCollectionExtensions.AddTensorCore(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32,System.UIntPtr)", new XmlComment(@"Adds Tensor.Core services with GPU memory pool configuration.", null, null, @"The service collection for chaining.", null, false, null, [new XmlParameterComment(@"services", @"The service collection.", null, false), new XmlParameterComment(@"maxBufferCount", @"Maximum number of pooled GPU buffers.", null, false), new XmlParameterComment(@"defaultBufferSize", @"Default buffer size in bytes.", null, false)], null));
            cache.Add(@"T:Microsoft.Extensions.DependencyInjection.TensorCoreOptions", new XmlComment(@"Configuration options for Tensor.Core services.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Microsoft.Extensions.DependencyInjection.TensorCoreOptions.MaxBufferCount", new XmlComment(@"Maximum number of buffers to pool. Default is 16.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Microsoft.Extensions.DependencyInjection.TensorCoreOptions.DefaultBufferSize", new XmlComment(@"Default buffer size in bytes. Default is 64 MB.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Microsoft.Extensions.DependencyInjection.TensorCoreOptions.PreferGpu", new XmlComment(@"Whether to prefer GPU operations when available. Default is true.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Microsoft.Extensions.DependencyInjection.TensorCoreOptions.EnableMetrics", new XmlComment(@"Enable detailed metrics collection. Default is true.", null, null, null, null, false, null, null, null));


            cache.Add(@"T:Aspire_Full.VectorStore.QdrantOptions", new XmlComment(@"Strongly typed configuration for connecting to a Qdrant instance.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.VectorStore.QdrantOptions.Endpoint", new XmlComment(@"Fully qualified HTTP or gRPC endpoint (e.g. http://qdrant:6334).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.VectorStore.QdrantOptions.ApiKey", new XmlComment(@"Optional API key used when connecting to managed Qdrant clusters.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.VectorStore.QdrantOptions.Collection", new XmlComment(@"Default collection name used for semantic operations.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.VectorStore.QdrantOptions.VectorSize", new XmlComment(@"Vector dimensionality expected by the collection.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.VectorStore.QdrantOptions.GrpcTimeoutSeconds", new XmlComment(@"Timeout, in seconds, applied to outbound gRPC calls.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.VectorStore.VectorDocument", new XmlComment(@"Represents a document stored in the vector store with upsert/downsert support.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.VectorStore.IVectorStoreService", new XmlComment(@"Service for vector storage operations with upsert/downsert (soft-delete) support.
Uses Qdrant as the underlying vector database.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.UpsertAsync(Aspire_Full.VectorStore.VectorDocument,System.Threading.CancellationToken)", new XmlComment(@"Upsert a document - creates if new, updates if exists, reactivates if soft-deleted.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.UpsertBatchAsync(System.Collections.Generic.IEnumerable{Aspire_Full.VectorStore.VectorDocument},System.Threading.CancellationToken)", new XmlComment(@"Upsert multiple documents in batch for GPU-efficient bulk operations.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.DownsertAsync(System.String,System.Threading.CancellationToken)", new XmlComment(@"Downsert (soft-delete) a document - marks as deleted but retains data.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.DeleteAsync(System.String,System.Threading.CancellationToken)", new XmlComment(@"Hard delete a document - permanently removes from store.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.DeleteBatchAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)", new XmlComment(@"Hard delete multiple documents in batch.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.SearchAsync(System.ReadOnlyMemory{System.Single},System.Int32,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"Search for similar documents using vector similarity.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.SearchBatchAsync(System.Collections.Generic.IEnumerable{System.ReadOnlyMemory{System.Single}},System.Int32,System.Boolean,System.Threading.CancellationToken)", new XmlComment(@"Search multiple vectors in batch for GPU-efficient bulk similarity search.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.GetAsync(System.String,System.Threading.CancellationToken)", new XmlComment(@"Get a document by ID.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.VectorStore.IVectorStoreService.EnsureCollectionAsync(System.String,System.Int32,System.Threading.CancellationToken)", new XmlComment(@"Ensure the collection exists with proper configuration.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.VectorStore.QdrantVectorStoreService", new XmlComment(@"Qdrant implementation of vector store with upsert/downsert pattern.
Optimized for GPU-accelerated workloads with SIMD support.", null, null, null, null, false, null, null, null));

            cache.Add(@"T:Aspire_Full.Api.Controllers.AdminController", new XmlComment(@"Admin controller for privileged operations.
Provides access to all users including soft-deleted, role management, and hard delete.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Api.Controllers.UsersController", new XmlComment(@"Controller for standard user operations including upsert and soft delete (downsert).", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Api.Data.AppDbContextFactory", new XmlComment(@"Design-time factory for EF Core migrations when the app isn't running.", null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Api.Migrations.InitialCreate", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Api.Migrations.FixPendingModelChanges", new XmlComment(null, null, null, null, null, false, null, null, null));
            cache.Add(@"T:Aspire_Full.Api.Models.User", new XmlComment(@"User entity representing both standard users and administrators.
Supports soft delete (downsert) and upsert patterns.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.Item.CreatedByUserId", new XmlComment(@"Foreign key to the user who created this item.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.Item.CreatedByUser", new XmlComment(@"Navigation property to the user who created this item.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.Email", new XmlComment(@"Unique email address for the user.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.DisplayName", new XmlComment(@"Display name shown in the UI.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.Role", new XmlComment(@"User's role: User or Admin.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.IsActive", new XmlComment(@"Whether the user account is active (false = soft deleted/downserted).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.CreatedAt", new XmlComment(@"When the user was created.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.UpdatedAt", new XmlComment(@"When the user was last updated.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.DeletedAt", new XmlComment(@"When the user was soft deleted (null if active).", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.LastLoginAt", new XmlComment(@"Last login timestamp.", null, null, null, null, false, null, null, null));
            cache.Add(@"P:Aspire_Full.Api.Models.User.Items", new XmlComment(@"Navigation property: Items created by this user.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.GetAllUsers(System.Boolean,System.Nullable{Aspire_Full.Shared.Models.UserRole})", new XmlComment(@"Get all users including soft-deleted (bypasses query filter).", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.GetUser(System.Int32)", new XmlComment(@"Get a specific user by ID (bypasses query filter).", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.PromoteToAdmin(System.Int32)", new XmlComment(@"Promote a user to admin role.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.DemoteToUser(System.Int32)", new XmlComment(@"Demote an admin to regular user role.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.ReactivateUser(System.Int32)", new XmlComment(@"Reactivate a soft-deleted user.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.HardDeleteUser(System.Int32)", new XmlComment(@"Hard delete a user permanently (irreversible).
Also removes all items created by this user.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.BulkDeactivateUsers(System.Int32[])", new XmlComment(@"Bulk soft-delete users by IDs.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.AdminController.GetStats", new XmlComment(@"Get user statistics.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.GetUsers", new XmlComment(@"Get all active users.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.GetUser(System.Int32)", new XmlComment(@"Get a specific user by ID.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.GetUserByEmail(System.String)", new XmlComment(@"Get user by email.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.UpsertUser(Aspire_Full.Shared.Models.CreateUser)", new XmlComment(@"Create or update a user (upsert operation).
If a user with the same email exists (including soft-deleted), reactivates and updates them.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.UpdateUser(System.Int32,Aspire_Full.Shared.Models.UpdateUser)", new XmlComment(@"Update user details.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.DownsertUser(System.Int32)", new XmlComment(@"Soft delete a user (downsert operation).
User is deactivated but data is retained.", null, null, null, null, false, null, null, null));
            cache.Add(@"M:Aspire_Full.Api.Controllers.UsersController.RecordLogin(System.Int32)", new XmlComment(@"Record user login.", null, null, null, null, false, null, null, null));

            return cache;
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class DocumentationCommentIdHelper
    {
        /// <summary>
        /// Generates a documentation comment ID for a type.
        /// Example: T:Namespace.Outer+Inner`1 becomes T:Namespace.Outer.Inner`1
        /// </summary>
        public static string CreateDocumentationId(this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            return "T:" + GetTypeDocId(type, includeGenericArguments: false, omitGenericArity: false);
        }

        /// <summary>
        /// Generates a documentation comment ID for a property.
        /// Example: P:Namespace.ContainingType.PropertyName or for an indexer P:Namespace.ContainingType.Item(System.Int32)
        /// </summary>
        public static string CreateDocumentationId(this PropertyInfo property)
        {
            if (property == null)
            {
                throw new ArgumentNullException(nameof(property));
            }

            var sb = new StringBuilder();
            sb.Append("P:");

            if (property.DeclaringType != null)
            {
                sb.Append(GetTypeDocId(property.DeclaringType, includeGenericArguments: false, omitGenericArity: false));
            }

            sb.Append('.');
            sb.Append(property.Name);

            // For indexers, include the parameter list.
            var indexParams = property.GetIndexParameters();
            if (indexParams.Length > 0)
            {
                sb.Append('(');
                for (int i = 0; i < indexParams.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    sb.Append(GetTypeDocId(indexParams[i].ParameterType, includeGenericArguments: true, omitGenericArity: false));
                }
                sb.Append(')');
            }

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation comment ID for a property given its container type and property name.
        /// Example: P:Namespace.ContainingType.PropertyName
        /// </summary>
        public static string CreateDocumentationId(Type containerType, string propertyName)
        {
            if (containerType == null)
            {
                throw new ArgumentNullException(nameof(containerType));
            }
            if (string.IsNullOrEmpty(propertyName))
            {
                throw new ArgumentException("Property name cannot be null or empty.", nameof(propertyName));
            }

            var sb = new StringBuilder();
            sb.Append("P:");
            sb.Append(GetTypeDocId(containerType, includeGenericArguments: false, omitGenericArity: false));
            sb.Append('.');
            sb.Append(propertyName);

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation comment ID for a method (or constructor).
        /// For example:
        ///   M:Namespace.ContainingType.MethodName(ParamType1,ParamType2)~ReturnType
        ///   M:Namespace.ContainingType.#ctor(ParamType)
        /// </summary>
        public static string CreateDocumentationId(this MethodInfo method)
        {
            if (method == null)
            {
                throw new ArgumentNullException(nameof(method));
            }

            var sb = new StringBuilder();
            sb.Append("M:");

            // Append the fully qualified name of the declaring type.
            if (method.DeclaringType != null)
            {
                sb.Append(GetTypeDocId(method.DeclaringType, includeGenericArguments: false, omitGenericArity: false));
            }

            sb.Append('.');

            // Append the method name, handling constructors specially.
            if (method.IsConstructor)
            {
                sb.Append(method.IsStatic ? "#cctor" : "#ctor");
            }
            else
            {
                sb.Append(method.Name);
                if (method.IsGenericMethod)
                {
                    sb.Append("``");
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}", method.GetGenericArguments().Length);
                }
            }

            // Append the parameter list, if any.
            var parameters = method.GetParameters();
            if (parameters.Length > 0)
            {
                sb.Append('(');
                for (int i = 0; i < parameters.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    // Omit the generic arity for the parameter type.
                    sb.Append(GetTypeDocId(parameters[i].ParameterType, includeGenericArguments: true, omitGenericArity: true));
                }
                sb.Append(')');
            }

            // Append the return type after a '~' (if the method returns a value).
            if (method.ReturnType != typeof(void))
            {
                sb.Append('~');
                // Omit the generic arity for the return type.
                sb.Append(GetTypeDocId(method.ReturnType, includeGenericArguments: true, omitGenericArity: true));
            }

            return sb.ToString();
        }

        /// <summary>
        /// Generates a documentation ID string for a type.
        /// This method handles nested types (replacing '+' with '.'),
        /// generic types, arrays, pointers, by-ref types, and generic parameters.
        /// The <paramref name="includeGenericArguments"/> flag controls whether
        /// constructed generic type arguments are emitted, while <paramref name="omitGenericArity"/>
        /// controls whether the generic arity marker (e.g. "`1") is appended.
        /// </summary>
        private static string GetTypeDocId(Type type, bool includeGenericArguments, bool omitGenericArity)
        {
            if (type.IsGenericParameter)
            {
                // Use `` for method-level generic parameters and ` for type-level.
                if (type.DeclaringMethod != null)
                {
                    return "``" + type.GenericParameterPosition;
                }
                else if (type.DeclaringType != null)
                {
                    return "`" + type.GenericParameterPosition;
                }
                else
                {
                    return type.Name;
                }
            }

            if (type.IsGenericType)
            {
                Type genericDef = type.GetGenericTypeDefinition();
                string fullName = genericDef.FullName ?? genericDef.Name;

                var sb = new StringBuilder(fullName.Length);

                // Replace '+' with '.' for nested types
                for (var i = 0; i < fullName.Length; i++)
                {
                    char c = fullName[i];
                    if (c == '+')
                    {
                        sb.Append('.');
                    }
                    else if (c == '`')
                    {
                        break;
                    }
                    else
                    {
                        sb.Append(c);
                    }
                }

                if (!omitGenericArity)
                {
                    int arity = genericDef.GetGenericArguments().Length;
                    sb.Append('`');
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}", arity);
                }

                if (includeGenericArguments && !type.IsGenericTypeDefinition)
                {
                    var typeArgs = type.GetGenericArguments();
                    sb.Append('{');

                    for (int i = 0; i < typeArgs.Length; i++)
                    {
                        if (i > 0)
                        {
                            sb.Append(',');
                        }

                        sb.Append(GetTypeDocId(typeArgs[i], includeGenericArguments, omitGenericArity));
                    }

                    sb.Append('}');
                }

                return sb.ToString();
            }

            // For non-generic types, use FullName (if available) and replace nested type separators.
            return (type.FullName ?? type.Name).Replace('+', '.');
        }

        /// <summary>
        /// Normalizes a documentation comment ID to match the compiler-style format.
        /// Strips the return type suffix for ordinary methods but retains it for conversion operators.
        /// </summary>
        /// <param name="docId">The documentation comment ID to normalize.</param>
        /// <returns>The normalized documentation comment ID.</returns>
        public static string NormalizeDocId(string docId)
        {
            // Find the tilde character that indicates the return type suffix
            var tildeIndex = docId.IndexOf('~');
            if (tildeIndex == -1)
            {
                // No return type suffix, return as-is
                return docId;
            }

            // Check if this is a conversion operator (op_Implicit or op_Explicit)
            // For these operators, we need to keep the return type suffix
            if (docId.Contains("op_Implicit") || docId.Contains("op_Explicit"))
            {
                return docId;
            }

            // For ordinary methods, strip the return type suffix
            return docId.Substring(0, tildeIndex);
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file class XmlCommentOperationTransformer : IOpenApiOperationTransformer
    {
        public Task TransformAsync(OpenApiOperation operation, OpenApiOperationTransformerContext context, CancellationToken cancellationToken)
        {
            var methodInfo = context.Description.ActionDescriptor is ControllerActionDescriptor controllerActionDescriptor
                ? controllerActionDescriptor.MethodInfo
                : context.Description.ActionDescriptor.EndpointMetadata.OfType<MethodInfo>().SingleOrDefault();

            if (methodInfo is null)
            {
                return Task.CompletedTask;
            }
            if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(methodInfo.CreateDocumentationId()), out var methodComment))
            {
                if (methodComment.Summary is { } summary)
                {
                    operation.Summary = summary;
                }
                if (methodComment.Description is { } description)
                {
                    operation.Description = description;
                }
                if (methodComment.Remarks is { } remarks)
                {
                    operation.Description = remarks;
                }
                if (methodComment.Parameters is { Count: > 0})
                {
                    foreach (var parameterComment in methodComment.Parameters)
                    {
                        var parameterInfo = methodInfo.GetParameters().SingleOrDefault(info => info.Name == parameterComment.Name);
                        var operationParameter = operation.Parameters?.SingleOrDefault(parameter => parameter.Name == parameterComment.Name);
                        if (operationParameter is not null)
                        {
                            var targetOperationParameter = UnwrapOpenApiParameter(operationParameter);
                            targetOperationParameter.Description = parameterComment.Description;
                            if (parameterComment.Example is { } jsonString)
                            {
                                targetOperationParameter.Example = jsonString.Parse();
                            }
                            targetOperationParameter.Deprecated = parameterComment.Deprecated;
                        }
                        else
                        {
                            var requestBody = operation.RequestBody;
                            if (requestBody is not null)
                            {
                                requestBody.Description = parameterComment.Description;
                                if (parameterComment.Example is { } jsonString)
                                {
                                    var content = requestBody?.Content?.Values;
                                    if (content is null)
                                    {
                                        continue;
                                    }
                                    foreach (var mediaType in content)
                                    {
                                        mediaType.Example = jsonString.Parse();
                                    }
                                }
                            }
                        }
                    }
                }
                // Applies `<returns>` on XML comments for operation with single response value.
                if (methodComment.Returns is { } returns && operation.Responses is { Count: 1 })
                {
                    var response = operation.Responses.First();
                    response.Value.Description = returns;
                }
                // Applies `<response>` on XML comments for operation with multiple response values.
                if (methodComment.Responses is { Count: > 0} && operation.Responses is { Count: > 0 })
                {
                    foreach (var response in operation.Responses)
                    {
                        var responseComment = methodComment.Responses.SingleOrDefault(xmlResponse => xmlResponse.Code == response.Key);
                        if (responseComment is not null)
                        {
                            response.Value.Description = responseComment.Description;
                        }
                    }
                }
            }
            foreach (var parameterDescription in context.Description.ParameterDescriptions)
            {
                var metadata = parameterDescription.ModelMetadata;
                if (metadata.MetadataKind == ModelMetadataKind.Property
                    && metadata.ContainerType is { } containerType
                    && metadata.PropertyName is { } propertyName)
                {
                    var propertyDocId = DocumentationCommentIdHelper.CreateDocumentationId(containerType, propertyName);
                    if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(propertyDocId), out var propertyComment))
                    {
                        var parameter = operation.Parameters?.SingleOrDefault(p => p.Name == metadata.Name);
                        var description = propertyComment.Summary;
                        if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(propertyComment.Value))
                        {
                            description = $"{description}\n{propertyComment.Value}";
                        }
                        else if (string.IsNullOrEmpty(description))
                        {
                            description = propertyComment.Value;
                        }
                        if (parameter is null)
                        {
                            if (operation.RequestBody is not null)
                            {
                                operation.RequestBody.Description = description;
                                if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                                {
                                    var content = operation.RequestBody.Content?.Values;
                                    if (content is null)
                                    {
                                        continue;
                                    }
                                    var parsedExample = jsonString.Parse();
                                    foreach (var mediaType in content)
                                    {
                                        mediaType.Example = parsedExample;
                                    }
                                }
                            }
                            continue;
                        }
                        var targetOperationParameter = UnwrapOpenApiParameter(parameter);
                        if (targetOperationParameter is not null)
                        {
                            targetOperationParameter.Description = description;
                            if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                            {
                                targetOperationParameter.Example = jsonString.Parse();
                            }
                        }
                    }
                }
            }

            return Task.CompletedTask;
        }

        private static OpenApiParameter UnwrapOpenApiParameter(IOpenApiParameter sourceParameter)
        {
            if (sourceParameter is OpenApiParameterReference parameterReference)
            {
                if (parameterReference.Target is OpenApiParameter target)
                {
                    return target;
                }
                else
                {
                    throw new InvalidOperationException($"The input schema must be an {nameof(OpenApiParameter)} or {nameof(OpenApiParameterReference)}.");
                }
            }
            else if (sourceParameter is OpenApiParameter directParameter)
            {
                return directParameter;
            }
            else
            {
                throw new InvalidOperationException($"The input schema must be an {nameof(OpenApiParameter)} or {nameof(OpenApiParameterReference)}.");
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file class XmlCommentSchemaTransformer : IOpenApiSchemaTransformer
    {
        public Task TransformAsync(OpenApiSchema schema, OpenApiSchemaTransformerContext context, CancellationToken cancellationToken)
        {
            // Apply comments from the type
            if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(context.JsonTypeInfo.Type.CreateDocumentationId()), out var typeComment))
            {
                schema.Description = typeComment.Summary;
                if (typeComment.Examples?.FirstOrDefault() is { } jsonString)
                {
                    schema.Example = jsonString.Parse();
                }
            }

            if (context.JsonPropertyInfo is { AttributeProvider: PropertyInfo propertyInfo })
            {
                // Apply comments from the property
                if (XmlCommentCache.Cache.TryGetValue(DocumentationCommentIdHelper.NormalizeDocId(propertyInfo.CreateDocumentationId()), out var propertyComment))
                {
                    var description = propertyComment.Summary;
                    if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(propertyComment.Value))
                    {
                        description = $"{description}\n{propertyComment.Value}";
                    }
                    else if (string.IsNullOrEmpty(description))
                    {
                        description = propertyComment.Value;
                    }
                    if (schema.Metadata is null
                        || !schema.Metadata.TryGetValue("x-schema-id", out var schemaId)
                        || string.IsNullOrEmpty(schemaId as string))
                    {
                        // Inlined schema
                        schema.Description = description;
                        if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                        {
                            schema.Example = jsonString.Parse();
                        }
                    }
                    else
                    {
                        // Schema Reference
                        if (!string.IsNullOrEmpty(description))
                        {
                            schema.Metadata["x-ref-description"] = description;
                        }
                        if (propertyComment.Examples?.FirstOrDefault() is { } jsonString)
                        {
                            schema.Metadata["x-ref-example"] = jsonString.Parse()!;
                        }
                    }
                }
            }
            return Task.CompletedTask;
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class JsonNodeExtensions
    {
        public static JsonNode? Parse(this string? json)
        {
            if (json is null)
            {
                return null;
            }

            try
            {
                return JsonNode.Parse(json);
            }
            catch (JsonException)
            {
                try
                {
                    // If parsing fails, try wrapping in quotes to make it a valid JSON string
                    return JsonNode.Parse($"\"{json.Replace("\"", "\\\"")}\"");
                }
                catch (JsonException)
                {
                    return null;
                }
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.OpenApi.SourceGenerators, Version=10.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60", "10.0.0.0")]
    file static class GeneratedServiceCollectionExtensions
    {
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "cSnH1SA7VmHz0v+sk2WjgbIDAABQcm9ncmFtLmNz")]
        public static IServiceCollection AddOpenApi(this IServiceCollection services)
        {
            return services.AddOpenApi("v1", options =>
            {
                options.AddSchemaTransformer(new XmlCommentSchemaTransformer());
                options.AddOperationTransformer(new XmlCommentOperationTransformer());
            });
        }

    }
}
